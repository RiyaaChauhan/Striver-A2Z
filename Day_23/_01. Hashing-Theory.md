
# Hashing 

## What is Hashing?

**Hashing** is a technique used to **map data of arbitrary size to data of a fixed size**, typically to enable **fast access** or **look-up**.

A **hash function** is used to compute an **index (or hash code)** into an array of buckets or slots, from which the desired value can be found.

> Think of it like a library: the book title is the key, and the book's location is determined by the hash function.

---

## Why Hashing?

- **Fast Search**: Ideal for scenarios where you need **quick lookups**, like checking whether an item exists in a collection.
- **Efficient Insertion & Deletion**
- **Handles large data** efficiently

---

## Real-world Applications

- Implementing **hash tables**
- **Caching** (e.g., LRU cache)
- **Databases indexing**
- **Data de-duplication**
- **Password storage** (cryptographic hashing)
- **Checksums** for data validation

---

## Basic Terminologies

| Term              | Description |
|------------------|-------------|
| **Key**           | The input to the hash function |
| **Hash Function** | Function that maps a key to an index |
| **Hash Table**    | The data structure that stores data using hashing |
| **Hash Value**    | Result of the hash function |
| **Bucket**        | A storage location in the hash table |
| **Collision**     | When two keys map to the same index |

---

## Hash Function

A **good hash function**:
- Should distribute keys uniformly across the table
- Should be fast to compute
- Should minimize collisions

### Example:
```python
hash_index = key % table_size
```

---

## Collision Handling Techniques

Collisions are **unavoidable**, so we need strategies to handle them:

### 1. **Chaining (Separate Chaining)**

- Each bucket is a **linked list** of entries that hash to the same index.

Pros:
- Easy to implement
- Can grow dynamically

Cons:
- Extra memory for pointers

### 2. **Open Addressing**

- When a collision occurs, **probe** for the next available slot.

#### Types of Open Addressing:

| Type                | Description |
|---------------------|-------------|
| **Linear Probing**   | Check next slot `(index + 1) % size` |
| **Quadratic Probing**| Use quadratic jumps to find next slot |
| **Double Hashing**   | Use second hash function to determine jump size |

---

## Time Complexity (Hash Table Operations)

| Operation | Average Case | Worst Case |
|-----------|--------------|-------------|
| Insert    | O(1)         | O(n) (with bad hash function) |
| Search    | O(1)         | O(n) |
| Delete    | O(1)         | O(n) |

In practice, with a **good hash function** and **load factor**, these are **almost always O(1)**.

---

## Load Factor

> Load Factor = (Number of elements in table) / (Size of table)

- **High load factor** = more collisions
- When it exceeds a threshold (usually 0.7), **rehashing** is triggered (resizing the table and re-inserting elements)

---

## Hash Table Implementations in Languages

| Language | Hashing Data Structure |
|----------|------------------------|
| Python   | `dict`, `set`          |
| Java     | `HashMap`, `HashSet`   |
| C++      | `unordered_map`, `unordered_set` |
| JavaScript | `Object`, `Map`, `Set` |

---

## Example in Python

```python
# Using dictionary (hash map)
hash_map = {}
hash_map['apple'] = 1
hash_map['banana'] = 2

print(hash_map['apple'])  # Output: 1
```

---

## Hashing-Based Problems in DSA

- Two Sum
- Subarray Sum Equals K
- Longest Consecutive Sequence
- Group Anagrams
- Top K Frequent Elements
- Isomorphic Strings

---

## Cryptographic Hashing (Extra Info)

Used for security-related applications (e.g., password storage, digital signatures)

Popular hash algorithms:
- MD5
- SHA-1, SHA-256

> These are **one-way** functions (you cannot reverse them), unlike regular hash functions.

---

## Summary

| Concept               | Key Points |
|------------------------|------------|
| **Hash Function**       | Maps keys to indices |
| **Hash Table**          | Stores data using hash function |
| **Collision Handling**  | Chaining or Open Addressing |
| **Time Complexity**     | Almost always O(1) for insert/search/delete |
| **Applications**        | Caching, lookups, indexing, passwords |